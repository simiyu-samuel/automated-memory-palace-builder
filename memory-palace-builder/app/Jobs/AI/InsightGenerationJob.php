<?php

namespace App\Jobs\AI;

use App\Models\Memory;
use App\Models\User;
use App\Models\UserInsight;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Foundation\Queue\Queueable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Carbon\Carbon;

class InsightGenerationJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    protected User $user;

    /**
     * Create a new job instance.
     */
    public function __construct(User $user)
    {
        $this->user = $user;
    }

    /**
     * Execute the job.
     */
    public function handle(): void
    {
        // 1. Fetch unprocessed memories for the user
        $memoriesToAnalyze = Memory::where('user_id', $this->user->id)
                                   ->where('is_processed', false)
                                   ->limit(20) // Limit for batch processing
                                   ->get();

        if ($memoriesToAnalyze->isEmpty()) {
            // If no unprocessed memories, try to generate insights from already processed ones
            $this->generateInsightsFromProcessedMemories();
            return;
        }

        // 2. Dispatch ContentAnalysisJob for each unprocessed memory
        foreach ($memoriesToAnalyze as $memory) {
            ContentAnalysisJob::dispatch($this->user->id, $memory->api_connection_id);
        }

        // 3. After dispatching, we can either wait for them to be processed
        //    or dispatch another job to run after a delay to check for processed memories.
        //    For simplicity, we'll assume they will be processed and then generate insights.
        //    In a real application, you might use a chain of jobs or a delayed job.
        
        // For now, we'll immediately try to generate insights from *all* processed memories
        // This might not include the ones just dispatched if the queue is slow.
        // A more robust solution would involve a delayed job or job chaining.
        $this->generateInsightsFromProcessedMemories();
    }

    /**
     * Generate insights from already processed memories.
     */
    private function generateInsightsFromProcessedMemories(): void
    {
        $processedMemories = Memory::where('user_id', $this->user->id)
                                   ->where('is_processed', true)
                                   ->orderBy('updated_at', 'desc')
                                   ->limit(10)
                                   ->get();

        if ($processedMemories->isEmpty()) {
            return; // No processed memories to generate insights from
        }

        $insightContent = "AI-powered insights based on your recent activities:\n\n";
        $sentimentSummary = ['positive' => 0, 'negative' => 0, 'neutral' => 0];
        $themes = [];
        $relatedMemoryIds = [];

        foreach ($processedMemories as $memory) {
            $insightContent .= "- **{$memory->title}** ({$memory->type}, Sentiment: {$memory->sentiment}): {$memory->description}\n";
            
            if ($memory->sentiment) {
                $sentimentSummary[$memory->sentiment]++;
            }
            
            if (isset($memory->processed_data['content_analysis']['themes'])) {
                $themes = array_merge($themes, $memory->processed_data['content_analysis']['themes']);
            }
            $relatedMemoryIds[] = $memory->id;
        }

        $mostCommonSentiment = array_keys($sentimentSummary, max($sentimentSummary))[0];
        $uniqueThemes = array_unique($themes);

        $insightContent .= "\nOverall Sentiment Trend: " . ucfirst($mostCommonSentiment) . "\n";
        if (!empty($uniqueThemes)) {
            $insightContent .= "Key Themes: " . implode(', ', $uniqueThemes) . "\n";
        }
        $insightContent .= "\nThese insights are generated by analyzing the content, sentiment, and themes of your memories.";

        UserInsight::create([
            'user_id' => $this->user->id,
            'type' => 'ai_summary',
            'category' => 'behavioral',
            'title' => 'AI-Generated Activity Summary',
            'description' => $insightContent,
            'confidence_score' => 0.9,
            'relevance_score' => 95,
            'period_start' => $processedMemories->last()->memory_date,
            'period_end' => $processedMemories->first()->memory_date,
            'related_memories' => $relatedMemoryIds,
            'is_active' => true,
            'is_read' => false,
            'expires_at' => Carbon::now()->addDays(30), // Insight expires in 30 days
        ]);
    }
}
